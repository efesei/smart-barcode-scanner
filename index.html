const statusElem = document.getElementById("status");
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const webhookUrlInput = document.getElementById("webhookUrl");
const webhookHistoryElem = document.getElementById("webhookHistory");
const saveSettingsBtn = document.getElementById("saveSettings");
const onlineStatus = document.getElementById("onlineStatus");
const scanDataElem = document.getElementById("scanData");
const clearScanBtn = document.getElementById("clearScanBtn");
const currentYearElem = document.getElementById("currentYear");
const permissionHelp = document.getElementById("permissionHelp");

currentYearElem.textContent = new Date().getFullYear();

let scanning = false;
let currentScanData = null;
let webhookUrl = localStorage.getItem("webhookUrl") || "";
let webhookHistory = JSON.parse(localStorage.getItem("webhookHistory") || "[]");
let html5QrCode = null;
let hasCameraPermission = false;

// Check camera permission on page load
async function checkCameraPermission() {
    try {
        // Try to enumerate devices to trigger permission prompt early
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        hasCameraPermission = videoDevices.some(device => device.deviceId !== '');
        
        if (!hasCameraPermission) {
            console.log("Camera permission not yet granted");
            permissionHelp.classList.add("show");
        }
    } catch (error) {
        console.log("Camera permission check failed:", error);
        permissionHelp.classList.add("show");
    }
}

// Initialize camera permission check
checkCameraPermission();

function initWebhookHistory() {
    if (webhookUrl) {
        webhookUrlInput.value = webhookUrl;
    }
    
    updateWebhookHistoryDisplay();
    
    webhookUrlInput.addEventListener('focus', () => {
        if (webhookHistory.length > 0) {
            webhookHistoryElem.classList.add('show');
        }
    });
    
    document.addEventListener('click', (e) => {
        if (!webhookUrlInput.contains(e.target) && !webhookHistoryElem.contains(e.target)) {
            webhookHistoryElem.classList.remove('show');
        }
    });
}

function updateWebhookHistoryDisplay() {
    webhookHistoryElem.innerHTML = '';
    
    if (webhookHistory.length === 0) {
        const emptyItem = document.createElement('div');
        emptyItem.className = 'webhook-history-item';
        emptyItem.textContent = 'No previous webhooks';
        emptyItem.style.color = '#999';
        emptyItem.style.fontStyle = 'italic';
        webhookHistoryElem.appendChild(emptyItem);
        return;
    }
    
    const recentHistory = webhookHistory.slice(0, 5);
    
    recentHistory.forEach(url => {
        const item = document.createElement('div');
        item.className = 'webhook-history-item';
        item.textContent = url;
        item.addEventListener('click', () => {
            webhookUrlInput.value = url;
            webhookHistoryElem.classList.remove('show');
            webhookUrlInput.focus();
        });
        webhookHistoryElem.appendChild(item);
    });
}

function addToWebhookHistory(url) {
    if (!url || url.trim() === '') return;
    
    webhookHistory = webhookHistory.filter(item => item !== url);
    webhookHistory.unshift(url);
    
    if (webhookHistory.length > 10) {
        webhookHistory = webhookHistory.slice(0, 10);
    }
    
    localStorage.setItem("webhookHistory", JSON.stringify(webhookHistory));
    updateWebhookHistoryDisplay();
}

const audioContext = new (window.AudioContext || window.webkitAudioContext)();
function playBeep() {
    try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 2000;
        oscillator.type = 'square';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
    } catch (e) {
        console.log("Audio context error:", e);
    }
}

function updateScanDisplay() {
    if (currentScanData) {
        scanDataElem.textContent = currentScanData;
        scanDataElem.classList.remove('empty');
    } else {
        scanDataElem.textContent = "No data scanned yet.";
        scanDataElem.classList.add('empty');
    }
}

function clearScanData() {
    currentScanData = null;
    updateScanDisplay();
    showNotification("Scan data cleared");
}

if ("Notification" in window && Notification.permission === "default") {
    Notification.requestPermission();
}

webhookUrlInput.value = webhookUrl;
initWebhookHistory();

function updateOnlineStatus() {
    onlineStatus.className = "status-indicator " + (navigator.onLine ? "online" : "offline");
}
updateOnlineStatus();
window.addEventListener("online", updateOnlineStatus);
window.addEventListener("offline", updateOnlineStatus);

saveSettingsBtn.addEventListener("click", () => {
    const newUrl = webhookUrlInput.value.trim();
    webhookUrl = newUrl;
    localStorage.setItem("webhookUrl", newUrl);
    
    addToWebhookHistory(newUrl);
    
    showNotification("‚úÖ Settings saved!", false);
    console.log("Webhook URL saved:", newUrl);
});

clearScanBtn.addEventListener("click", clearScanData);

async function sendScanData(scanData) {
    if (!navigator.onLine || !webhookUrl) return;
    
    try {
        const payload = {
            barcode_data: scanData.barcode_data,
            timestamp: scanData.timestamp,
            scanned_at: scanData.timestamp,
            code_type: scanData.code_type || "QR_CODE"
        };

        console.log("Sending to webhook:", JSON.stringify(payload, null, 2));

        const res = await fetch(webhookUrl, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(payload)
        });
        
        console.log("Webhook response:", res.status, res.statusText);
        
        if (res.ok) {
            showNotification("‚úÖ Data sent to webhook!");
        } else {
            showNotification("‚ö†Ô∏è Webhook error: " + res.status, true);
        }
    } catch (err) { 
        console.error("Send error:", err);
        showNotification("‚ö†Ô∏è Failed to send data", true);
    }
}

function showNotification(message, isError = false) {
    if ("Notification" in window && Notification.permission === "granted") {
        new Notification("Deft Barcode Scanner", {
            body: message,
            icon: "https://cdn-icons-png.flaticon.com/512/864/864685.png"
        });
    }

    const notif = document.createElement("div");
    notif.className = "notification" + (isError ? " error" : "");
    notif.textContent = message;
    document.body.appendChild(notif);
    setTimeout(() => notif.remove(), 3000);
}

// Success callback for scanning
async function onScanSuccess(decodedText, decodedResult) {
    if (!scanning) return;
    
    console.log("Scan successful:", decodedText);
    console.log("Format:", decodedResult.result.format);
    
    // Stop scanning immediately
    scanning = false;
    stopBtn.click();
    
    playBeep();
    
    const data = {
        barcode_data: decodedText,
        timestamp: new Date().toISOString(),
        code_type: decodedResult.result.format?.formatName || "QR_CODE",
        sent: false
    };
    
    statusElem.textContent = `‚úÖ Scan Complete! Type: ${data.code_type}`;
    
    showNotification(`‚úÖ ${data.code_type} Scanned!`);
    
    currentScanData = decodedText;
    updateScanDisplay();
    
    if (navigator.onLine && webhookUrl) {
        await sendScanData(data);
    }
    
    setTimeout(() => {
        statusElem.textContent = "Tap 'Start Scanner' to scan next item.";
    }, 2000);
}

// Improved error callback
function onScanError(errorMessage) {
    // Ignore common "not found" errors - they're expected during scanning
    if (!errorMessage.includes("NotFoundException")) {
        console.warn("Scan error:", errorMessage);
        
        // Check for permission-related errors
        if (errorMessage.includes("permission") || errorMessage.includes("NotAllowedError")) {
            statusElem.textContent = "‚ùå Camera permission denied. Please allow camera access.";
            permissionHelp.classList.add("show");
            stopBtn.click();
        }
    }
}

startBtn.addEventListener("click", async () => {
    if (scanning) return;
    
    if (!webhookUrl) {
        showNotification("‚ö†Ô∏è Please configure webhook URL first!", true);
        return;
    }

    clearScanData();
    
    scanning = true;
    startBtn.style.display = "none";
    stopBtn.style.display = "inline-block";
    statusElem.textContent = "Requesting camera access...";

    try {
        html5QrCode = new Html5Qrcode("reader");
        
        // First, check if we can access cameras
        let cameras;
        try {
            // This will trigger permission prompt if not already granted
            cameras = await Html5Qrcode.getCameras();
            console.log("Available cameras:", cameras);
            
            if (!cameras || cameras.length === 0) {
                throw new Error("No cameras found on device");
            }
            
            hasCameraPermission = true;
            permissionHelp.classList.remove("show");
            
        } catch (cameraError) {
            console.error("Camera access error:", cameraError);
            
            if (cameraError.name === 'NotAllowedError' || 
                cameraError.message.includes('permission') ||
                cameraError.message.includes('NotAllowed')) {
                
                statusElem.textContent = "‚ùå Camera permission denied. Please allow camera access in browser settings.";
                permissionHelp.classList.add("show");
                throw new Error("Camera permission denied by user");
            } else {
                throw cameraError;
            }
        }
        
        // OPTIMIZED configuration for dense QR codes
        const config = {
            fps: 30,
            qrbox: { width: 300, height: 300 },
            aspectRatio: 1.0,
            formatsToSupport: [
                Html5QrcodeSupportedFormats.QR_CODE,
                Html5QrcodeSupportedFormats.DATA_MATRIX,
                Html5QrcodeSupportedFormats.AZTEC,
                Html5QrcodeSupportedFormats.PDF_417,
                Html5QrcodeSupportedFormats.EAN_13,
                Html5QrcodeSupportedFormats.EAN_8,
                Html5QrcodeSupportedFormats.CODE_128,
                Html5QrcodeSupportedFormats.CODE_39,
                Html5QrcodeSupportedFormats.UPC_A,
                Html5QrcodeSupportedFormats.UPC_E
            ],
            experimentalFeatures: {
                useBarCodeDetectorIfSupported: true
            }
        };

        // Try using specific camera ID (environment/back camera preferred)
        let cameraId = { facingMode: "environment" };
        
        // If we got camera list, use the back camera
        if (cameras && cameras.length > 0) {
            // Try to find back/environment camera
            const backCamera = cameras.find(cam => 
                cam.label && (cam.label.toLowerCase().includes('back') || 
                             cam.label.toLowerCase().includes('environment') ||
                             cam.label.toLowerCase().includes('rear'))
            );
            cameraId = backCamera ? backCamera.id : cameras[0].id;
            console.log("Using camera:", cameraId);
        }

        statusElem.textContent = "Starting camera...";
        
        await html5QrCode.start(
            cameraId,
            config,
            onScanSuccess,
            onScanError
        );
        
        statusElem.textContent = "üì∑ Camera ready. Point at QR code or barcode...";

    } catch (err) {
        console.error("Scanner initialization error:", err);
        
        let errorMessage = "‚ùå Camera access failed: ";
        
        if (err.message.includes('permission') || err.message.includes('NotAllowed')) {
            errorMessage += "Permission denied. Please allow camera access.";
            permissionHelp.classList.add("show");
        } else if (err.message.includes('No cameras found')) {
            errorMessage += "No camera found on this device.";
        } else if (err.message.includes('Could not start video source')) {
            errorMessage += "Camera is already in use by another application.";
        } else {
            errorMessage += err.message;
        }
        
        statusElem.textContent = errorMessage;
        showNotification("‚ö†Ô∏è " + errorMessage, true);
        
        scanning = false;
        startBtn.style.display = "inline-block";
        stopBtn.style.display = "none";
        
        // Clean up
        if (html5QrCode) {
            try {
                await html5QrCode.stop();
                html5QrCode.clear();
            } catch (stopError) {
                console.log("Cleanup error:", stopError);
            }
            html5QrCode = null;
        }
    }
});

stopBtn.addEventListener("click", async () => {
    if (!scanning && !html5QrCode) return;
    
    scanning = false;
    startBtn.style.display = "inline-block";
    stopBtn.style.display = "none";
    
    try {
        if (html5QrCode) {
            await html5QrCode.stop();
            html5QrCode.clear();
            html5QrCode = null;
        }
        statusElem.textContent = "Tap 'Start Scanner' to scan next item.";
    } catch (err) {
        console.error("Stop error:", err);
    }
});

// Add a manual permission reset button
const resetPermissionBtn = document.createElement("button");
resetPermissionBtn.textContent = "üîÑ Reset Camera Permission";
resetPermissionBtn.style.marginTop = "10px";
resetPermissionBtn.style.background = "#ff9800";
resetPermissionBtn.addEventListener("click", async () => {
    try {
        // Try to get user media and immediately stop it to reset permission state
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        stream.getTracks().forEach(track => track.stop());
        showNotification("‚úÖ Camera permission reset. Please refresh the page.");
    } catch (error) {
        showNotification("‚ùå Could not reset camera permission.", true);
    }
});
document.getElementById("settings").appendChild(resetPermissionBtn);

if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("service-worker.js")
        .then((reg) => console.log("Service Worker Registered", reg))
        .catch(() => console.warn("Service worker registration failed"));
}

window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    const installBtn = document.createElement("button");
    installBtn.textContent = "üì≤ Install App";
    Object.assign(installBtn.style, {
        position:"fixed",
        bottom:"80px",
        left:"50%",
        transform:"translateX(-50%)",
        background:"#00b894",
        color:"#fff",
        border:"none",
        borderRadius:"6px",
        padding:"10px 20px",
        fontSize:"16px",
        cursor:"pointer",
        zIndex:"9999"
    });
    document.body.appendChild(installBtn);
    installBtn.addEventListener("click", async () => {
        installBtn.remove();
        e.prompt();
        const choice = await e.userChoice;
        if (choice.outcome === "accepted") showNotification("‚úÖ App installed!");
        else showNotification("‚ÑπÔ∏è Installation cancelled");
    });
});

updateScanDisplay();
